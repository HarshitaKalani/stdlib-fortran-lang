#:set WITH_QP = False
#:set WITH_XDP = False
#:include "common.fypp"
#:set CI_KINDS_TYPES = INT_KINDS_TYPES + CMPLX_KINDS_TYPES
module stdlib_specialfunctions_gamma
    use iso_fortran_env, only : qp => real64
    use stdlib_kinds, only :  sp, dp, int8, int16, int32, int64
    use stdlib_error, only : error_stop

    implicit none
    private

    integer(int8), parameter :: max_fact_int8 = 6_int8
    integer(int16), parameter :: max_fact_int16 = 8_int16
    integer(int32), parameter :: max_fact_int32 = 13_int32
    integer(int64), parameter :: max_fact_int64 = 21_int64

    #:for k1, t1 in REAL_KINDS_TYPES
    ${t1}$, parameter :: tol_${k1}$ = epsilon(1.0_${k1}$)
    #:endfor
    real(qp), parameter :: tol_qp = epsilon(1.0_qp)



    public :: mgamma, log_gamma, log_factorial
    public :: lower_incomplete_gamma, log_lower_incomplete_gamma
    public :: upper_incomplete_gamma, log_upper_incomplete_gamma
    public :: regularized_gamma_p, regularized_gamma_q



    interface mgamma
    !! Gamma function for integer and complex numbers
    !!
        #:for k1, t1 in CI_KINDS_TYPES
        module procedure gamma_${t1[0]}$${k1}$
        #:endfor
    end interface mgamma






contains

    #:for k1, t1 in INT_KINDS_TYPES
    impure elemental function gamma_${t1[0]}$${k1}$(z) result(res)
        ${t1}$, intent(in) :: z
        ${t1}$ :: res, i
        ${t1}$, parameter :: zero = 0_${k1}$, one = 1_${k1}$

        if(z <= zero) call error_stop("Error(gamma): Gamma function argument"  &
            //" must be positive integer.")

        if(z > max_fact_${k1}$) call error_stop("Error(gamma): Gamma function" &
            //" integer argument is greater than the upper limit from which an"&
            //" integer overflow will be generated. Suggest switch to high "   &
            //" precision or convert to real data type")

        res = one

        do i = one, z - one

            res = res * i

        end do

    end function gamma_${t1[0]}$${k1}$

    #:endfor




    #:for k1, t1 in CMPLX_KINDS_TYPES
      #:if k1 == "sp"
          #:set k2 = "dp"
      #:elif k1 == "dp"
          #:set k2 = "qp"
      #:endif
      #:set t2 = "real({})".format(k2)

    impure elemental function gamma_${t1[0]}$${k1}$(z) result(res)
        ${t1}$, intent(in) :: z
        ${t1}$ :: res
        integer :: i

        real(${k1}$), parameter :: zero_k1 = 0.0_${k1}$
        ${t2}$, parameter :: zero = 0.0_${k2}$, half = 0.5_${k2}$,             &
                             one = 1.0_${k2}$, pi = acos(- one), sqpi = sqrt(pi)
        complex(${k2}$) :: y, x, sum

        #:if k1 == "sp"
          #! for single precision input, using double precision for calculation

        integer, parameter :: n = 10
        ${t2}$, parameter :: r = 10.900511_${k2}$
        ${t2}$, parameter :: d(0 : n) = [2.48574089138753566e-5_${k2}$,        &
                                             1.05142378581721974_${k2}$,       &
                                            -3.45687097222016235_${k2}$,       &
                                             4.51227709466894824_${k2}$,       &
                                            -2.98285225323576656_${k2}$,       &
                                             1.05639711577126713_${k2}$,       &
                                         -1.95428773191645870e-1_${k2}$,       &
                                          1.70970543404441224e-2_${k2}$,       &
                                         -5.71926117404305781e-4_${k2}$,       &
                                          4.63399473359905637e-6_${k2}$,       &
                                         -2.71994908488607704e-9_${k2}$]
        ! parameters from above referenced source.

        #:elif k1 == "dp"
          #! for double precision input, using quadruple precision for calculation

        integer, parameter :: n = 24
        ${t2}$, parameter :: r = 25.617904_${k2}$
        ${t2}$, parameter :: d(0 : n)=                                         &
                         [1.0087261714899910504854136977047144166e-11_${k2}$,  &
                              1.6339627701280724777912729825256860624_${k2}$,  &
                          -1.4205787702221583745972794018472259342e+1_${k2}$,  &
                           5.6689501646428786119793943350900908698e+1_${k2}$,  &
                          -1.3766376824252176069406853670529834070e+2_${k2}$,  &
                           2.2739972766608392140035874845640820558e+2_${k2}$,  &
                          -2.7058382145757164380300118233258834430e+2_${k2}$,  &
                          2.39614374587263042692333711131832094166e+2_${k2}$,  &
                          -1.6090450559507517723393498276315290189e+2_${k2}$,  &
                          8.27378183187161305711485619113605553100e+1_${k2}$,  &
                          -3.2678977082742592701862249152153110206e+1_${k2}$,  &
                             9.89018079175824824537131521501652931756_${k2}$,  &
                             -2.2762136356329318377213053650799013041_${k2}$,  &
                          3.93265017303573867227590563182750070164e-1_${k2}$,  &
                          -5.0051054352146209116457193223422284239e-2_${k2}$,  &
                          4.57142601898244576789629257292603538238e-3_${k2}$,  &
                          -2.8922592124650765614787233510990416584e-4_${k2}$,  &
                          1.20833375377219592849746118012697473202e-5_${k2}$,  &
                          -3.1220812187551248389268359432609135033e-7_${k2}$,  &
                          4.55117045361638520378367871355819524460e-9_${k2}$,  &
                         -3.2757632817493581828033170342853173968e-11_${k2}$,  &
                         9.49784279240135747819870224486376897253e-14_${k2}$,  &
                         -7.9480594917454410117072562195702526836e-17_${k2}$,  &
                         1.04692819439870077791406760109955648941e-20_${k2}$,  &
                         -5.8990280044857540075384586350723191533e-26_${k2}$]
        ! parameters from above referenced source.

        #:endif



        if(abs(z % im) < tol_${k1}$) then

            res = cmplx(gamma(z % re), kind = ${k1}$)
            return

        end if

        if(z % re < zero_k1) then

            x = cmplx(abs(z % re), - z % im, kind = ${k1}$)
            y = x - one

        else

            y = z - one

        end if

!        sum = cmplx(d(0), kind = ${k2}$)

        do i = 1, n

            sum = sum + d(i) / (y + i)

        end do

        y = exp((y + half) * log(y + half + r) - y) * sum

        y = y * 2 / sqpi                         !Re(z) > 0 return

        if(z % re < zero_k1 ) then

            y = - pi / (sin(pi * x) * x * y)     !Re(z) < 0 return

        end if

        res = y
    end function gamma_${t1[0]}$${k1}$

    #:endfor





end module stdlib_specialfunctions_gamma
